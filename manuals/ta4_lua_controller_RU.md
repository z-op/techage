# Контроллер TA4 Lua

![TA4 Lua Controller](https://github.com/joe7575/techage/blob/master/textures/techage_lua_controller_inventory.png)

Контроллер TA4 Lua — это небольшой компьютер, программируемый на языке Lua для управления вашими механизмами.  
В отличие от контроллера ICTA, этот контроллер позволяет реализовывать более крупные и сложные программы.  
Однако для написания скриптов на Lua требуются базовые знания языка программирования Lua.

Minetest использует Lua 5.1. Справочная документация по Lua 5.1 доступна [здесь](https://www.lua.org/manual/5.1/).  
Книга [«Programming in Lua» (первое издание)](https://www.lua.org/pil/contents.html) также является отличным источником для изучения Lua.

Руководство по контроллеру TA4 Lua также доступно в формате PDF:  
https://github.com/joe7575/techage/blob/master/manuals/ta4_lua_controller_EN.pdf

## Содержание

- [Контроллер TA4 Lua](#контроллер-ta4-lua)
- [Содержание](#содержание)
- [Блоки TA4 Lua Controller](#блоки-ta4-lua-controller)
  - [TA4 Lua Controller](#ta4-lua-controller)
  - [TA4 Lua Server](#ta4-lua-server)
  - [Терминал TA4 Lua Controller](#терминал-ta4-lua-controller)
  - [TA4 Sensor Chest](#ta4-sensor-chest)
- [Функции и среда выполнения Lua](#функции-и-среда-выполнения-lua)
  - [Функции и ограничения Lua](#функции-и-ограничения-lua)
  - [Массивы, хранилища и множества](#массивы-хранилища-и-множества)
    - [Массивы](#массивы)
    - [Хранилища](#хранилища)
    - [Множества](#множества)
- [Инициализация, циклические задачи и события](#инициализация-циклические-задачи-и-события)
  - [Инициализация](#инициализация)
  - [Циклическая задача](#циклическая-задача)
  - [События](#события)
- [Среда выполнения на основе кредитов](#среда-выполнения-на-основе-кредитов)
- [Функции контроллера Lua](#функции-контроллера-lua)
  - [Локальные функции контроллера](#локальные-функции-контроллера)
  - [Пример ввода](#пример-ввода)
  - [Функции команд Techage](#функции-команд-techage)
  - [Функции сервера и терминала](#функции-сервера-и-терминала)
  - [Обмен сообщениями между контроллерами Lua](#обмен-сообщениями-между-контроллерами-lua)
  - [Дополнительные функции](#дополнительные-функции)
- [Примеры скриптов](#примеры-скриптов)
  - [Простой счётчик](#простой-счётчик)
  - [Hello World](#hello-world)
  - [Цикл for с range(from, to)](#цикл-for-с-rangefrom-to)
  - [Мониторинг сундука и печи](#мониторинг-сундука-и-печи)
  - [Простой калькулятор](#простой-калькулятор)
  - [Приветственный дисплей](#приветственный-дисплей)
  - [Sensor Chest](#sensor-chest)
  - [Чтение кнопки «TA4 4x Button»](#чтение-кнопки-ta4-4x-button)
  - [Электронная почта](#электронная-почта)

## Блоки TA4 Lua Controller

### TA4 Lua Controller

Блок контроллера имеет меню со следующими вкладками:

- вкладка `init` — для блока кода инициализации  
- вкладка `func` — для определения пользовательских функций на Lua  
- вкладка `loop` — для основного блока кода  
- вкладка `outp` — для вывода отладочной информации через `$print()`  
- вкладка `notes` — для хранения фрагментов кода или заметок (аналог буфера обмена)  
- вкладка `help` — справочная информация о доступных функциях  

Контроллер перезапускается (вызывается `init()`) каждый раз при перезапуске сервера Minetest.  
Для сохранения данных после перезапуска сервера необходимо использовать блок **«TA4 Lua Server»**.

### TA4 Lua Server

Блок сервера используется для постоянного (энергонезависимого) хранения данных от контроллеров Lua.  
Также он может использоваться для обмена данными между несколькими контроллерами Lua.  
Доступ к серверу имеют только указанные игроки. Для этого в меню сервера можно ввести список имён игроков.  
О специальных функциях сервера см. раздел «Функции сервера и терминала».

### Терминал TA4 Lua Controller

Терминал используется для отправки текстовых команд контроллеру.  
В свою очередь, контроллер может отправлять текстовые строки терминалу.  
Терминал имеет встроенную справку по внутренним командам. Поддерживаемые команды:

- `clear` — очистить экран  
- `help` — вывести это сообщение  
- `pub` — перевести терминал в публичный режим (любой может вводить команды)  
- `priv` — перевести терминал в приватный режим (только владелец может вводить команды)  
- `send <num> on/off` — отправить событие включения/выключения, например, лампе (для тестирования)  
- `msg <num> <text>` — отправить текстовое сообщение другому контроллеру (для тестирования)  

О специальных функциях терминала для контроллера TA4 Lua см. раздел «Функции сервера и терминала».

### TA4 Sensor Chest

*Подлежит уточнению.*

## Функции и среда выполнения Lua

### Функции и ограничения Lua

Контроллер использует подмножество языка Lua под названием **SaferLua**. Оно обеспечивает безопасное выполнение скриптов, но имеет следующие ограничения:

- ограниченная длина кода  
- ограниченное время выполнения  
- ограниченное использование памяти  
- ограниченные возможности вызова функций  

SaferLua следует стандартному синтаксису Lua со следующими ограничениями:

- запрещены циклы `while` и `repeat` (для предотвращения бесконечных циклов)  
- запрещён конструктор таблиц `{..}`; вместо него см. раздел «Массивы, хранилища и множества»  
- ограниченная среда выполнения  

SaferLua напрямую поддерживает следующие стандартные функции:

- `math.floor`, `math.abs`, `math.max`, `math.min`, `math.random`  
- `tonumber`, `tostring`, `unpack`, `type`  
- `string.byte`, `string.char`, `string.find`, `string.format`, `string.gmatch`, `string.gsub`, `string.len`, `string.lower`, `string.match`, `string.rep`, `string.sub`, `string.upper`  
- `string.split` (результат — Array)  
- `string.split2` (результат — несколько значений, как у `unpack`)  
- `string.trim`  

Для определения собственных функций используйте вкладку меню `func`. Пример:

```
function foo(a, b)
    return a + b
end
```

Не забудьте добавить символ `$` перед именем функции при её вызове в основном коде:  
`$foo(1, 2)`

Каждая программа SaferLua имеет доступ к следующим системным переменным:

- `ticks` — счётчик, увеличивающийся на 1 при каждом вызове `loop()`  
- `elapsed` — количество секунд, прошедших с последнего вызова `loop()`  
- `event` — флаг (true/false), сигнализирующий, что `loop()` был вызван в ответ на событие  

### Массивы, хранилища и множества

Невозможно легко контролировать использование памяти таблицами Lua во время выполнения. Поэтому в SaferLua нельзя использовать обычные таблицы Lua. Вместо них предусмотрены следующие безопасные обёртки:

#### Массивы

Массивы — это списки элементов, к которым можно обращаться по индексу. Индекс должен быть целым числом. Первый элемент имеет индекс 1.  

Методы массива:

- `add(value)` — добавить новый элемент в конец массива  
- `set(idx, value)` — заменить существующий элемент по индексу `idx`  
- `get(idx)` — получить значение элемента по индексу `idx`  
- `remove(idx)` — удалить элемент по индексу `idx`  
- `insert(idx, val)` — вставить новый элемент по индексу `idx` (массив удлиняется)  
- `size()` — вернуть количество элементов  
- `memsize()` — вернуть объём занимаемой памяти  
- `next()` — итератор для цикла `for`, возвращает `idx,val`  
- `sort(reverse)` — сортировать элементы на месте; если `reverse == true`, сортировка по убыванию  

Пример:

```
a = Array(1,2,3,4)     --> {1,2,3,4}
a.add(6)               --> {1,2,3,4,6}
a.set(2, 8)            --> {1,8,3,4,6}
a.get(2)               --> функция возвращает 8
a.insert(5,7)          --> {1,8,3,4,7,6}
a.remove(3)            --> {1,8,4,7,6}
a.insert(1, "hello")   --> {"hello",1,8,4,7,6}
a.size()               --> функция возвращает 6
a.memsize()            --> функция возвращает 10
for idx,val in a.next() do
    ...
end
```

#### Хранилища

В отличие от массивов, хранилища индексируются ключами (строками или числами). Основные операции — сохранение значения по ключу и извлечение значения по ключу.

Методы хранилища:

- `set(key, val)` — сохранить/перезаписать значение `val` по ключу `key`  
- `get(key)` — прочитать значение по ключу `key`  
- `del(key)` — удалить значение по ключу  
- `size()` — количество элементов  
- `memsize()` — объём памяти  
- `next()` — итератор для цикла `for`, возвращает `key,val`  
- `keys(order)` — вернуть массив ключей; если `order == "up"` или `"down"`, ключи сортируются по значениям  

Пример:

```
s = Store("a", 4, "b", 5)  --> {a = 4, b = 5}
s.set("val", 12)           --> {a = 4, b = 5, val = 12}
s.get("val")               --> возвращает 12
s.set(0, "hello")          --> {a = 4, b = 5, val = 12, [0] = "hello"}
s.del("val")               --> {a = 4, b = 5, [0] = "hello"}
s.size()                   --> функция возвращает 3
s.memsize()                --> функция возвращает 9
for key,val in s.next() do
    ...
end
```

Пример сортировки ключей:

```
s = Store()            --> {}
s.set("Joe", 800)      --> {Joe=800}
s.set("Susi", 1000)    --> {Joe=800, Susi=1000}
s.set("Tom", 60)       --> {Joe=800, Susi=1000, Tom=60}
s.keys()               --> {Joe, Susi, Tom}
s.keys("down")         --> {Susi, Joe, Tom}
s.keys("up")           --> {Tom, Joe, Susi}
```

#### Множества

Множество — неупорядоченная коллекция без дубликатов. Основное назначение — проверка наличия элемента (например, имени игрока).

Методы множества:

- `add(val)` — добавить значение  
- `del(val)` — удалить значение  
- `has(val)` — проверить наличие значения  
- `size()` — количество элементов  
- `memsize()` — объём памяти  
- `next()` — итератор для цикла `for`, возвращает `idx,val`  

Пример:

```
s = Set("Tom", "Lucy")     --> {Tom = true, Lucy = true}
s.add("Susi")              --> {Tom = true, Lucy = true, Susi = true}
s.del("Tom")               --> {Lucy = true, Susi = true}
s.has("Susi")              --> функция возвращает `true`
s.has("Mike")              --> функция возвращает `false`
s.size()                   --> функция возвращает 2
s.memsize()                --> функция возвращает 8
for idx,val in s.next() do
    ...
end
```

Все три типа структур данных допускают вложенные элементы (например, множество внутри хранилища), но общий объём всех структур не может превышать заданного лимита. Значение лимита настраивается администратором сервера; по умолчанию — 1000.  

Текущий лимит можно узнать с помощью `memsize()`:

```
memsize()  --> функция возвращает 1000 (пример)
```

## Инициализация, циклические задачи и события

Контроллер TA4 Lua различает фазу инициализации (сразу после запуска) и фазу нормальной работы.

### Инициализация

Функция `init()` выполняется один раз при запуске контроллера. Обычно используется для инициализации переменных, очистки дисплея или сброса других блоков:

```
-- инициализация переменных
counter = 1
table = Store()
player_name = "unknown"

-- сброс блоков
$clear_screen("123")      -- "123" — номер дисплея
$send_cmnd("2345", "off") -- выключить блоки с номером "2345"
```

### Циклическая задача

Во время нормальной работы функция `loop()` вызывается циклически.  
Сюда помещается код, который должен выполняться повторно.  

Частота вызова по умолчанию — раз в секунду, но её можно изменить:

```
$loopcycle(0)   -- отключить цикл
$loopcycle(1)   -- вызывать loop() каждую секунду
$loopcycle(10)  -- вызывать loop() каждые 10 секунд
```

Указываемое число должно быть целым. Частоту можно менять как в `init()`, так и в `loop()`.

### События

Для немедленной реакции на полученные команды контроллер поддерживает события.  
События по умолчанию отключены, но их можно включить функцией `events()`:

```
$events(true)   -- включить события
$events(false)  -- выключить события
```

Если происходит событие (приходит команда от другого блока), вызывается `loop()` (в дополнение к обычному циклу). При этом устанавливается системная переменная `event`:

```
if event then
    -- произошло событие
    if $get_input("3456") == "on" then  -- проверка входа от блока "3456"
        -- выполнить действие...
    end
end
```

Первое событие обрабатывается немедленно, последующие могут быть отложены.  
Контроллер допускает максимум одно событие каждые 100 мс.

## Среда выполнения на основе кредитов

Контроллер TA4 Lua использует **кредитную модель выполнения**.  
Каждая инструкция Lua расходует определённое количество кредитов.  
Кредиты пополняются каждый цикл (обычно раз в секунду) на 10 единиц.  
Максимальный запас — 100 кредитов. Если кредиты исчерпаны, выполнение приостанавливается до пополнения.  

Ранее использовавшаяся временная модель всё ещё активна, но применяется только для защиты от бесконечных циклов.

## Функции контроллера Lua

Помимо стандартных функций Lua, контроллер предоставляет следующие функции:

### Локальные функции контроллера

- `$print(text)` — вывод текста на вкладку `outp` меню контроллера  
  Пример: `$print("Привет, "..name)`
- `$loopcycle(seconds)` — изменить частоту вызова `loop()` (по умолчанию — 1 сек)  
- `$events(bool)` — включить/выключить обработку событий  
- `$get_ms_time()` — вернуть текущее время с точностью до миллисекунд  
- `$get_gametime()` — вернуть время в секундах с момента создания мира  
- `$time_as_str()` — вернуть игровое время суток в виде строки (24-часовой формат, например "18:45")  
- `$time_as_num()` — вернуть игровое время суток в виде целого числа (например, 1845)  
- `$get_input(num)` — прочитать входное значение от внешнего блока с номером `num` (тип строки, например "1234"). Блок должен быть настроен на отправку команд (`on`/`off`) этому контроллеру.

### Пример ввода

Детектор игроков с номером "456" настроен на отправку команд `on`/`off` контроллеру TA4 Lua с номером "345".  
Контроллер получает эти команды как входные значения.  
Программа может всегда читать последнее значение от детектора:

```
sts = $get_input("456")
```

### Функции команд Techage

Функция `$send_cmnd(num, ident, add_data)` позволяет отправлять команды и получать данные от другого блока с номером `num`.

Команды делятся на две логические группы: **чтение данных** и **выполнение действия**.

#### Чтение данных

| ident | возвращаемые данные | комментарий |
|-------|---------------------|-------------|
| `"state"` | `"running"`, `"stopped"`, `"blocked"`, `"standby"`, `"fault"`, `"unloaded"` | состояние машины Techage |
| `"state"` | `"red"`, `"amber"`, `"green"`, `"off"` | состояние сигнальной вышки |
| `"state"` | `"empty"`, `"loaded"`, `"full"` | состояние сундука или Sensor Chest |
| `"state"` | `"on"`, `"off"` | состояние кнопки TA4 |
| `"fuel"` | число | уровень топлива (0–99) |
| `"depth"` | число | текущая глубина карьера (1–80) |
| `"load"` | число | уровень заряда аккумулятора или теплонакопителя (0–100%) |
| `"load"` | два числа | для резервуара/силоса: процент и абсолютное значение |
| `"load"` | число | уровень заряда сети от TA3 Power Terminal (0–100%) |
| `"delivered"` | число | выдаваемая мощность генератора (в ку); для потребителей — отрицательное значение |
| `"flowrate"` | число | общий поток жидкости (только для насосов TA4) |
| `"action"` | имя_игрока, строка_действия | только для Sensor Chest |
| `"stacks"` | Array из Stores | содержимое инвентаря (до 4 слотов) |
| `"count"` | число | счётчик предметов в TA4 Item Detector |
| `"count"` | число | общее количество предметов в TA4 (8×2000) сундуке; `add_data` — номер слота (1–8) |
| `"count"` | число | количество вытолкнутых предметов (режим ограничителя потока) |
| `"count"` | число | количество перекачанных единиц жидкости (режим ограничителя потока) |
| `"itemstring"` | строка | техническое имя предмета в указанном слоте сундука |
| `"output"` | строка | результат рецепта печи (например, `"default:glass"`); `"unknown"` — если рецепт не активен |
| `"input"` | список | чтение рецепта из TA4 Recipe Block по индексу |
| `"name"` | строка | имя игрока от детектора или кнопки |
| `"time"` | число | время нажатия кнопки в тиках (1 тик = 100 мс) |
| `"consumption"` | число | потреблённая энергия (TA4 Electric Meter) |
| `"countdown"` | число | обратный отсчёт энергии (TA4 Electric Meter) |
| `"current"` | число | сила тока (TA4 Electric Meter) |

#### Выполнение действия

| команда | данные | комментарий |
|--------|--------|-------------|
| `"on"`, `"off"` | nil | вкл/выкл блок (машина, лампа и т.д.) |
| `"red"`, `"amber"`, `"green"`, `"off"` | nil | установить цвет вышки или светофора |
| `"red"`, `"amber"`, `"green"`, `"off"` | номер лампы (1–4) | для TA4 2x/4x Signal Lamp |
| `"port"` | строка `<цвет>=on/off` | вкл/выкл фильтр распределителя (цвета: red, green, blue, yellow) |
| `"config"` | `"<слот> <список предметов>"` | настройка фильтра распределителя |
| `"text"` | строка | текст для меню Sensor Chest |
| `"reset"` | nil | сброс счётчиков TA4 Item Detector |
| `"countdown"` | число | установить обратный отсчёт в TA4 Item Detector |
| `"limit"` | число | установить лимит для толкателя или насоса (режим ограничителя потока); 0 — отключить режим |
| `"config"` | строка предмета | настроить толкатель (например, `wool:blue`) |
| `"exc"` | номер слота | TA3 Door Controller II: обменять блок в мире с блоком из инвентаря |
| `"to1"` | номер слота | TA3 Door Controller II: переместить блок из мира в инвентарь (состояние 2) |
| `"to2"` | номер слота | TA3 Door Controller II: переместить блок из инвентаря в мир (состояние 1) |
| `"get"` | номер слота | TA3 Door Controller II: получить состояние позиции (1 или 2) |
| `"a2b"` | nil | TA4 Move Controller: переместить блоки из позиции A в B |
| `"b2a"` | nil | TA4 Move Controller: переместить блоки из позиции B в A |
| `"move"` | nil | TA4 Move Controller: переместить блоки в противоположную позицию |
| `"move2"` | x,y,z | TA4 Move Controller: переместить блоки на заданное смещение (-100…100) |
| `"moveto"` | x,y,z | TA4 Move Controller / II: переместить блоки в абсолютные координаты |
| `"reset"` | nil | TA4 Move Controller / II: сброс в начальную позицию |
| `"left"` | nil | TA4 Turn Controller: повернуть блоки влево |
| `"right"` | nil | TA4 Turn Controller: повернуть блоки вправо |
| `"uturn"` | nil | TA4 Turn Controller: разворот на 180° |
| `"recipe"` | список предметов | установить рецепт для TA4 Autocrafter (пустые поля допустимы только в конце) |
| `"recipe"` | `<номер>.<индекс>` | загрузить рецепт из TA4 Recipe Block |
| `"goto"` | `<слот>` | запустить TA4 Sequencer с указанного слота |
| `"stop"` | nil | остановить TA4 Sequencer |
| `"gain"` | громкость (0–1.0) | установить громкость звукового блока |
| `"sound"` | индекс | выбрать звуковой сэмпл |
| `"color"` | число (0–255) | установить цвет TechAge Color Lamp |

### Функции сервера и терминала

Сервер используется для постоянного хранения данных и обмена между контроллерами.

- `$server_write(num, key, value)` — записать значение на сервер.  
  `key` — строка, `value` — число, строка, булево, nil или структура данных (без вложенности).  
  Пример: `$server_write("0123", "state", state)`
- `$server_read(num, key)` — прочитать значение с сервера.  
- `$get_term()` — прочитать текстовую команду от терминала  
- `$put_term(num, text)` — отправить текст терминалу  

### Обмен сообщениями между контроллерами Lua

Сообщения используются для передачи данных между контроллерами. Входящие сообщения хранятся в очереди (до 10 штук).

- `$get_msg([raw])` — прочитать сообщение. Возвращает номер отправителя (строка) и само сообщение. Если `raw` не задан или false, сообщение гарантированно строка.  
- `$send_msg(num, msg)` — отправить сообщение контроллеру с номером `num` (строка).

### Дополнительные функции

- `$chat(text)` — отправить себе сообщение в чат  
- `$door(pos, text)` — открыть/закрыть дверь по координатам.  
  Пример: `$door("123,7,-1200", "close")`  
  Подсказка: используйте Techage Info Tool для определения координат.
- `$item_description("default:apple")` — получить локализованное название предмета по его техническому имени  
  Пример:
  ```
  str = $send_cmnd("223", "itemstring", 1)
  descr = $item_description(str)
  ```
- `$display(num, row, text)` — отправить текст на дисплей.  
  `row`: 1–5 — строка; 0 — прокрутка снизу.  
  Если первый символ — пробел, текст центрируется по горизонтали.
- `$clear_screen(num)` — очистить экран дисплея  
- `$position(num)` — вернуть позицию устройства в виде строки `"(x,y,z)"`  

## Примеры скриптов

### Простой счётчик

Очень простой пример с выводом в меню контроллера.

init() code:
```lua
a = 1
```

loop() code:
```lua
a = a + 1
$print("a = "..a)
```

### Hello World

Пример с выводом на дисплей.

init() code:
```lua
a = Array("Привет", "мир", "Minetest")

$clear_screen("0669")

for i,text in a.next() do
    $display("0669", i, text)
end
```

### Цикл for с range(from, to)

Альтернативная реализация Hello World с использованием цикла `range`.

init() code:
```lua
a = Array("Привет", "мир", "Minetest")

$clear_screen("0669")

for i in range(1, 4) do
	text = a.get(i)
	$display("0669", i, text)
end
```

### Мониторинг сундука и печи

Более реалистичный пример: чтение состояния толкателей и вывод на дисплей.

init() code:
```lua
DISPLAY = "1234"  -- укажите номер вашего дисплея
min = 0
```

loop() code:
```lua
-- выполнять код каждые 60 сек
if ticks % 60 == 0 then
    -- вывод времени в минутах
    min = min + 1
    $display(DISPLAY, 1, min.. " мин ")

    -- переполнение сундука кактуса
    sts = $send_cmnd("1034", "state") -- статус толкателя
    if sts == "blocked" then $display(DISPLAY, 2, "Кактус полон") end

    -- переполнение сундука дерева
    sts = $send_cmnd("1065", "state")
    if sts == "blocked" then $display(DISPLAY, 3, "Дерево полон") end

    -- печь без топлива
    sts = $send_cmnd("1544", "state")
    if sts == "standby" then $display(DISPLAY, 4, "Топливо в печи") end
end
```

### Простой калькулятор

Калькулятор, суммирующий введённые числа через терминал.

init() code:
```lua
$events(true)
$loopcycle(0)

TERM = "360" -- номер терминала (подставьте свой!)
sum = 0
$put_term(TERM, "сумма = "..sum)
```

loop() code:
```lua
s = $get_term() -- читаем текст из терминала
if s then
    val = tonumber(s) or 0
    sum = sum + val
    text = string.format("+%d = %d", val, sum)
    $put_term(TERM, text)
end
```

### Приветственный дисплей

При обнаружении игрока его имя выводится на дисплей.

init() code:
```lua
$events(true)
$loopcycle(0)

SENSOR = "365"   -- номер детектора игроков
DISPLAY = "367"  -- номер дисплея

$clear_screen(DISPLAY)
```

loop() code:
```lua
if event then
    name = $send_cmnd(SENSOR, "name")
    if name == "" then -- игроков рядом нет
        $clear_screen(DISPLAY)
    else
        $display(DISPLAY, 2, " Добро пожаловать")
        $display(DISPLAY, 3, " "..name)
    end
end
```

### Sensor Chest

Пример работы с Sensor Chest.

init() code:
```lua
$events(true)
$loopcycle(0)

SENSOR = "372"   -- номер Sensor Chest

$send_cmnd(SENSOR, "text", "нажмите обе кнопки и\nположите что-нибудь в сундук")
```

loop() code:
```lua
if event and $get_input(SENSOR) == "on" then
    -- состояние инвентаря
    state = $send_cmnd(SENSOR, "state")
    $print("состояние: "..state)
    -- имя игрока и действие
    name, action = $send_cmnd(SENSOR, "action")
    $print("действие: "..name.." "..action)
    -- содержимое инвентаря
    stacks = $send_cmnd(SENSOR, "stacks")
    for i,stack in stacks.next() do
        $print("стак: "..stack.get("name").."   "..stack.get("count"))
    end
    $print(" ")
end
```

### Чтение кнопки «TA4 4x Button»

Кнопка TA4 4x Button не отправляет команды `on`/`off`, поэтому для получения её сигналов используется `$get_msg()`.

Кнопка должна быть настроена с командами вида: `msg 1`, `msg 2`, и т.д.

init() code:
```lua
$events(true)
$loopcycle(0)

BUTTON = "372"   -- номер TA4 4x Button
```

loop() code:
```lua
if event then
    num,text = $get_msg()
    if num == BUTTON then
        $print("кнопка: " .. text)
    end
end
```

При нажатии кнопок окно `outp` будет содержать:


```
button: 1
button: 4
button: 3
button: 2
```

### Электронная почта

Для создания системы электронной почты вам понадобятся TA4 Lua Server и по одному TA4 Lua Controller с терминалом на каждого игрока.  
TA4 Lua Server выступает в роли базы данных для сопоставления имён игроков и номеров блоков.

* Каждому игроку необходим собственный терминал и контроллер. Терминал должен быть подключён к контроллеру.  
* На всех контроллерах выполняется один и тот же скрипт на Lua; отличаются только номера блоков и имена владельцев.  
* Чтобы отправить сообщение, введите в терминал имя получателя и текст сообщения в формате `Том: привет`.  
* Скрипт Lua определит номер получателя и отправит сообщение соответствующему контроллеру.  
* Все игроки, которые должны иметь возможность участвовать в системе электронной почты, должны быть добавлены в форму сервера.

```lua
$loopcycle(0)
$events(true)

-- НАЧАЛО: подставьте свои данные
TERM = "360"
CONTROLLER = "359"
NAME = "Том"
SERVER = "363"
-- КОНЕЦ

$print($server_write(SERVER, NAME, CONTROLLER))
$print($server_write(SERVER, CONTROLLER, NAME))

```

loop()
```lua
-- отправка
s = $get_term()
if s then
    name,text = string.split2(s, ":", false, 1)
    num = $server_read(SERVER, name)
    if num then
        $send_msg(num, text)
        $put_term(TERM, "сообщение отправлено")
    end
end

-- получение
num,text = $get_msg()
if num then
    name = $server_read(SERVER, num)
    if name then
        $put_term(TERM, name..": "..text)
    end
end
```
